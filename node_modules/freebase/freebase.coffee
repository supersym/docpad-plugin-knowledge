
#interface to freebase's mql api

#is it an array of sub-queries?

#turn a string into a confident topic id

#is it an array of sub-tasks?

#if its a freebase-type object

#if its a url

#filter-out shit results

#kill low-relevance

#kill if 2nd result is also notable

#kill if types are crap

# freebase.lookup(["/m/09jm8", "http://myspace.com/u2"])

#like freebase.lookup but only needs an id

#if its a freebase-type object

#is an id

#is a normal search

#topic api

#is it an array of sub-tasks?

# if(options.filter){url+='&filter='+encodeURIComponent(options.filter)}
# if(options.key){url+='&key='+options.key}

#freebase.topic("toronto", {filter:"allproperties"})

#regular search api

#is it an array of sub-tasks?

#freebase.search("bill murray")

#get all of the results to your query

#is it an array of sub-tasks?

# if(_.isObject(query)){query=[query]}

#recursive mqlread until cursor is false, or maximum reached

#get the proper pronoun to use for a topic eg. he/she/they/it

#is it an array of sub-tasks?

#people grammar
#male
#female
#no gender person
#not a person
#plural topics

#categories that need a 'the' instead of 'a'

#freebase.grammar("toronto maple leafs")
#freebase.grammar("wayne gretzky")
#freebase.grammar("ron weasley")

#turns a url into a freebase topic and list its same:as links

#is it an array of sub-tasks?

#get its formatted links from the topic api

#same-as ones

#webpage ones

#return specific language title for a topic

#is it an array of sub-tasks?
#defaulting to french is better than an error..?

#get a url for image href of on this topic

#is it an array of sub-tasks?

#get a text blurb from freebase

#is it an array of sub-tasks?

#get a topics notable type

#is it an array of sub-tasks?

#get the first sentence of a topic description

#is it an array of sub-tasks?
#remove birthdates

#get a list of topics in a type

#is it an array of sub-tasks?

#singularize it if it's a search query

#get its id

#freebase.list("hurricanes",{}, function(r){console.log('========================')})
#freebase.list("/book/author")
list_category_like = (q, options, callback) ->
  callback = callback or console.log
  return callback({})  unless q
  options = options or {}
  q = fns.singularize(q)
  freebase.topic q, options, (r) ->
    return callback([])  if not r or not r.property or not _.isObject(r.property)
    all = Object.keys(r.property).filter((v) ->
      fns.isin v, data.category_like
    ).map((p) ->
      
      #add the property
      r.property[p].values = r.property[p].values.map((v) ->
        v.property = p
        v
      )
      r.property[p].values
    )
    all = _.flatten(all)
    callback all


#list_category_like("city")

#from a geo-coordinate, get the town, province, country, and timezone for it

#is it an array of sub-tasks?

#hunt for the most appropriate topics in 2 layers

#second layer looks good too

# freebase.place_data({lat:51.545414293637286,lng:-0.07589578628540039}, {}, console.log)

#get any incoming data to this topic, //ignoring cvt types

#is it an array of sub-tasks?

#this technically doesn't paginate.

#return all outgoing links for a topic, traversing cvt types

#is it an array of sub-tasks?

#get rid of permissions and stuff..

#add topics

#add the topics from cvt values in the same manner

#add sentence-forms

#freebase.outgoing("rob ford")

#return all outgoing and incoming links for a topic

#is it an array of sub-tasks?

#add the sentences

#freebase.graph("toronto")
parse_topic_api = (properties, options) ->
  out = []
  properties = kill_boring(properties)
  Object.keys(properties).forEach (key) ->
    v = properties[key]
    
    #add topics
    if v.valuetype is "object"
      v.values = v.values.map((s) ->
        s.property = key
        s
      )
      out = out.concat(v.values)
    
    #add the topics from cvt values in the same manner
    if v.valuetype is "compound"
      v.values.forEach (c) ->
        c.property = kill_boring(c.property)
        Object.keys(c.property).forEach (key2) ->
          if c.property[key2].valuetype is "object"
            c.property[key2].values = c.property[key2].values.map((s) ->
              s.property = [key, key2]
              s
            )
            out = out.concat(c.property[key2].values)



  out = out.map((o) ->
    name: o.text
    id: o.id
    property: o.property
  )
  out = out.map((o) ->
    o.property = o.property.join("")  if _.isArray(o.property)
    o
  )
  out

#get similar topics to a topic

#is it an array of sub-tasks?

#pluck relevant connected topics from outgoing links

#randomize the results

#else, append topics that share the notable type

# freebase.related("toronto", {key:"AIzaSyD5GmnQC7oW9GJIWPGsJUojspMMuPusAxI"}, function(r){
#   console.log(JSON.stringify(r, null, 2));
# })

#get a list of identifiers for a topic

#is it an array of sub-tasks?

#freebase.is_a("toronto")

#is it an array of sub-tasks?

#straight-up id search

#look for these properties in the topic api

# freebase.question("keanu reeves", {property:"children"})
#freebase.question("thom yorke", "produced")
#freebase.question("pulp fiction", {property:"/film/film/initial_release_date"})

# console.log(data.properties.filter(function(v){return v.cvt}))
#freebase.question("keanu reeves","films")

#transitive query on a specific property, maximum 3-ply

#is it an array of sub-tasks?

# freebase.dig('/en/bovid', {property:'/biology/organism_classification/lower_classifications'}, function(r){
#   console.log(r.length)
# })
# freebase.dig('/en/toronto', {property:'/location/location/contains'}, function(r){
#   console.log(r)
# })

#list of topics with images

#is it an array of sub-tasks?

# freebase.gallery('hurricanes')

#query wordnet via freebase

#is it an array of sub-tasks?

# freebase.wordnet(["bat","wood"])

#do a transitive-query, like all rivers in canada, using freebase metaschema

#is it an array of sub-tasks?

#lat/long for a topic

#is it an array of sub-tasks?

#freebase.geolocation("cn tower")

#list of topics nearby a location

#is it an array of sub-tasks?

#use the *old* freebase api for this, as there's no alternative in the new one

#freebase.nearby("cn tower", {type:"/food/restaurant"}, console.log)

#list of topics inside a location

#is it an array of sub-tasks?

#handy to have their geocoordinates too

#get a url for dbpedia based on this topic

#is it an array of sub-tasks?

#freebase.dbpedia_page("Köppen climate classification ")
#http://dbpedia.org/resource/K%2400F6ppen_climate_classification

#get all data from dbpedia for this topic

#is it an array of sub-tasks?

#freebase.dbpedia_data("Köppen climate classification", {}, console.log)
# freebase.dbpedia_data("Toronto", console.log)
dbpedia_to_freebase = (url) ->
  return ""  if not url or not url.match(/https?:\/\/dbpedia\.org\/(page|data|resource)\//i)
  url = url.replace(/https?:\/\/dbpedia\.org\/(page|data|resource)\//i, "") or ""
  url = decodeURI(url)
  "/wikipedia/en/" + fns.mql_encode(url.replace(RegExp(" ", "g"), "_"))

#get a url for wikipedia based on this topic

#is it an array of sub-tasks?
#'http://en.wikipedia.org/wiki/'

# freebase.wikipedia_page('toronto')

#is it an array of sub-tasks?

#if its not a wikipedia title, reuse get-topic logic for searches/ids

#freebase.wikipedia_categories(["Thom Yorke","Toronto"], {}, console.log)
#freebase.wikipedia_categories("Thom Yorke", {}, console.log)

#outgoing links from this wikipedia page, converted to freebase ids

#is it an array of sub-tasks?

#if its not a wikipedia title, reuse get-topic logic for searches/ids

#filter-out non-freebase topics

#freebase.wikipedia_links("Toronto", {}, console.log)

#outgoing links from this wikipedia page, converted to freebase ids

#is it an array of sub-tasks?

#if its not a wikipedia title, reuse get-topic logic for searches/ids

#freebase.wikipedia_external_links("/en/toronto", {}, console.log)

#lookup property matches offline..
property_lookup = (property) ->
  property = property.toLowerCase()
  property = property.replace(RegExp("  "), " ")
  property = property.replace(/^\s+|\s+$/, "")
  property_singular = fns.singularize(property)
  candidate_properties = data.properties.filter((v) ->
    v.id is property or v.name is property or v.name is property_singular
  )
  candidate_properties

#lookup metaschema predicate matches offline..
metaschema_lookup = (property) ->
  property = property.toLowerCase()
  property = property.replace(/\W(is|was|are|will be|has been)\W/, " ")
  property = property.replace(RegExp("  ", "g"), " ")
  property = property.replace(/_/g, " ")
  property = property.replace(/^\s+|\s+$/, "")
  candidate_properties = data.metaschema.filter((v) ->
    v.aliases = v.aliases or []
    v.id is property or v.name.toLowerCase() is property or fns.isin(property, v.aliases) or v.search_filter_operand.replace(/_/g, " ") is property
  )[0]
  candidate_properties = candidate_properties or {}
  candidate_properties.search_filter_operand

#console.log(metaschema_lookup('built with'))

#slightly different lookup when its a url
url_lookup = (q, options, callback) ->
  url = host + "search?type=/common/topic&limit=1&query=" + encodeURIComponent(q)
  url += "&key=" + options.key  if options.key
  fns.http url, (result) ->
    callback result


#kill the freebase internal-properties that don't feel graphy
kill_boring = (obj) ->
  return {}  unless obj
  data.boring.forEach (v) ->
    delete obj[v]

  obj
host = "https://www.googleapis.com/freebase/v1/"
image_host = "https://usercontent.googleapis.com/freebase/v1/image"
geosearch = "http://api.freebase.com/api/service/geosearch"
wikipedia_host = "http://en.wikipedia.org/w/api.php"
request = require("request")
async = require("async")
_ = require("underscore")
fns = require("./lib/helpers")
data = require("./lib/data.js").data
freebase = {}
freebase.mqlread = (query, options, callback) ->
  callback = callback or console.log
  return callback({})  unless query
  options = options or {}
  options.uniqueness_failure = options.uniqueness_failure or "soft"
  options.cursor = options.cursor or ""
  return fns.doit_async(query, freebase.mqlread, options, callback)  if _.isArray(query) and query.length > 1
  params = fns.set_params(options)
  url = host + "mqlread?query=" + encodeURIComponent(JSON.stringify(query)) + "&" + params
  fns.http url, (result) ->
    callback result


freebase.lookup = (q, options, callback) ->
  callback = callback or console.log
  return callback({})  unless q
  options = options or {}
  return fns.doit_async(q, freebase.lookup, options, callback)  if _.isArray(q) and q.length > 1
  if _.isObject(q)
    if (q.id? or q.mid?) and q.name?
      return callback(q)
    else
      q = q.id or q.mid
  if q.match(/^(https?:\/\/|www\.)/)
    return url_lookup(q, options, (result) ->
      return callback(result.result[0])  if result and result.result and result.result[0]
      callback {}
    )
  options.type = options.type or "/common/topic"
  url = host + "search?limit=2&lang=en&type=" + options.type + "&filter="
  url += encodeURIComponent("(any name{full}:\"" + q + "\" alias{full}:\"" + q + "\" id:\"" + q + "\")")
  url += "&key=" + options.key  if options.key
  fns.http url, (result) ->
    return callback({})  if not result or not result.result or not result.result[0]
    result = result.result or []
    result[0] = result[0] or {}
    result[1] = result[1] or {}
    return callback({})  if not result[0].score and result[0].score < 30
    return callback({})  if not ((result[0].score or 0) * 0.7) > (result[1].score or 0)
    kill = ["/music/track", "/music/release_track", "/tv/tv_episode", "/music/recording", "/music/composition", "/book/book_edition"]
    return callback({})  if result[1] and result[0].notable and fns.isin(result[0].notable.id, kill)
    result[0].name = result[0].text
    callback result[0]


freebase.get_id = (q, options, callback) ->
  q = q.id or q.mid or q.name  if _.isObject(q)
  return callback(id: q)  if not q or (q.match(/\/.{1,12}\/.{3}/)?)
  freebase.lookup q, options, (result) ->
    if options.type = "/type/type"
      return callback(result)
    else if result and result.mid
      result.id = result.id or result.mid
      return callback(result)
    callback {}


freebase.topic = (q, options, callback) ->
  callback = callback or console.log
  return callback({})  unless q
  options = options or {}
  return fns.doit_async(q, freebase.topic, options, callback)  if _.isArray(q) and q.length > 1
  freebase.get_id q, options, (topic) ->
    id = topic.id
    return callback({})  unless id
    options.filter = options.filter or "all"
    url = host + "topic" + id + "?" + fns.set_params(options)
    fns.http url, (result) ->
      callback result



freebase.search = (q, options, callback) ->
  callback = callback or console.log
  return callback([])  if not q and not options.filter
  options = options or {}
  return fns.doit_async(q, freebase.search, options, callback)  if _.isArray(q) and q.length > 1
  options.query = q or ""
  options.filter = encodeURIComponent(options.filter)  if options.filter
  options.query = encodeURIComponent(options.query)
  params = fns.set_params(options)
  url = host + "search/?" + params
  fns.http url, (result) ->
    return callback([])  if not result or not result.result or not result.result[0]
    callback result.result


freebase.paginate = (query, options, callback) ->
  iterate = (cursor) ->
    options.cursor = cursor
    freebase.mqlread query, options, (result) ->
      return callback(all)  if not result or not result.result
      all = all.concat(result.result)
      if result.cursor and (not options.max or all.length < options.max)
        iterate result.cursor
      else
        callback all

  callback = callback or console.log
  return callback([])  unless query
  options = options or {}
  options.max = options.max or 500
  return fns.doit_async(query, freebase.paginate, options, callback)  if _.isArray(query) and query.length > 1
  all = []
  iterate ""

freebase.grammar = (q, options, callback) ->
  callback = callback or console.log
  return callback({})  unless q
  options = options or {}
  return fns.doit_async(q, freebase.pronoun, options, callback)  if _.isArray(q) and q.length > 1
  freebase.get_id q, options, (topic) ->
    return callback({})  if not topic or not topic.id
    query = [
      id: topic.id
      name: null
      type: []
      "/people/person/gender": [
        id: null
        optional: true
      ]
      "/fictional_universe/fictional_character/gender": [
        id: null
        optional: true
      ]
    ]
    freebase.mqlread query, options, (result) ->
      return callback("")  if not result or not result.result or not result.result[0]
      result = result.result[0]
      grammar =
        plural: false
        gender: null
        article: "a"
        pronoun: "it"
        copula: "is"

      if fns.isin("/people/person", result.type) or fns.isin("/fictional_universe/fictional_character", result.type)
        gender = result["/people/person/gender"][0] or result["/fictional_universe/fictional_character/gender"][0]
        if gender
          if gender.id is "/en/male"
            grammar.gender = "male"
            grammar.pronoun = "he"
          else if gender.id is "/en/female"
            grammar.gender = "female"
            grammar.pronoun = "she"
        else
          grammar.gender = "unknown"
          grammar.pronoun = "they"
      else
        if _.intersection(data.plural_types, result.type).length > 0
          grammar.plural = true
          grammar.pronoun = "they"
          grammar.copula = "are"
        grammar.article = "the"  if _.intersection(data.definate_articles, result.type).length > 0
      callback grammar



freebase.same_as_links = (q, options, callback) ->
  callback = callback or console.log
  return callback({})  unless q
  options = options or {}
  options.filter = options.filter or "/common/topic"
  return fns.doit_async(q, freebase.same_as_links, options, callback)  if _.isArray(q) and q.length > 1
  url = host + "search?type=/common/topic&limit=1&query=" + encodeURIComponent(q)
  url += "&key=" + options.key  if options.key
  fns.http url, (result) ->
    return callback({})  if not result or not result.result or not result.result[0]
    freebase.topic result.result[0].mid, options, (all) ->
      links = []
      if all.property["/common/topic/topic_equivalent_webpage"]
        links = all.property["/common/topic/topic_equivalent_webpage"].values.map((v) ->
          href: v.value
          title: fns.parseurl(v.value).authority
        )
      if all.property["/common/topic/topical_webpage"]
        links = links.concat(all.property["/common/topic/topical_webpage"].values.map((v) ->
          host = fns.parseurl(v.value).authority or ""
          href: v.value
          title: host.replace(/^www\./, "")
        ))
      obj =
        topic: result.result[0]
        links: links

      callback obj



freebase.translate = (q, options, callback) ->
  callback = callback or console.log
  return callback({})  unless q
  options = options or {}
  return fns.doit_async(q, freebase.translate, options, callback)  if _.isArray(q) and q.length > 1
  options.lang = "/lang/fr"  unless options.lang
  options.lang = "/lang/" + options.lang  unless options.lang.match(/\/lang\//)
  freebase.get_id q, options, (topic) ->
    return callback("")  if not topic or not topic.id
    query = [
      id: topic.id
      name: [
        lang: options.lang
        value: null
      ]
    ]
    freebase.mqlread query, {}, (result) ->
      return callback("")  if not result or not result.result or not result.result[0]
      name = result.result[0].name or [{}]
      name = name[0].value or ""
      callback name



freebase.image = (q, options, callback) ->
  callback = callback or console.log
  return callback({})  unless q
  options = options or {}
  options.maxheight = options.maxheight or 250
  options.maxwidth = options.maxwidth or 250
  options.errorid = options.errorid or "/m/0djw4wd"
  return fns.doit_async(q, freebase.image, options, callback)  if _.isArray(q) and q.length > 1
  freebase.get_id q, options, (topic) ->
    return callback("")  if not topic or not topic.id
    query = [
      id: topic.id
      name: null
      "/common/topic/image": [id: null]
    ]
    freebase.mqlread query, options, (result) ->
      return callback("")  if not result or not result.result or not result.result[0] or not result.result[0]["/common/topic/image"][0]
      url = image_host + result.result[0]["/common/topic/image"][0].id
      params = fns.set_params(options)
      url += "?" + params
      callback url



freebase.description = (q, options, callback) ->
  callback = callback or console.log
  return callback({})  unless q
  options = options or {}
  return fns.doit_async(q, freebase.description, options, callback)  if _.isArray(q) and q.length > 1
  freebase.get_id q, options, (topic) ->
    return callback("")  if not topic or not topic.id
    url = host + "text/" + topic.id
    url += "?key=" + options.key  if options.key
    fns.http url, (result) ->
      return callback("")  unless result.result
      callback result.result



freebase.notable = (q, options, callback) ->
  callback = callback or console.log
  return callback({})  unless q
  options = options or {}
  return fns.doit_async(q, freebase.notable, options, callback)  if _.isArray(q) and q.length > 1
  freebase.topic q,
    filter: "/common/topic/notable_types"
  , (result) ->
    return callback({})  if not result or not result.property or not result.property["/common/topic/notable_types"]
    notable = result.property["/common/topic/notable_types"] or values: []
    notable.values[0].name = notable.values[0].text
    callback notable.values[0]


freebase.sentence = (q, options, callback) ->
  callback = callback or console.log
  return callback({})  unless q
  options = options or {}
  return fns.doit_async(q, freebase.sentence, options, callback)  if _.isArray(q) and q.length > 1
  freebase.description q, options, (desc) ->
    return callback("")  unless desc
    desc = fns.sentenceparser(desc) or []
    desc = desc[0] or ""
    desc = desc.replace(/\(.*?\)/g, "")
    desc = desc.replace(RegExp("  ", "g"), " ")
    callback desc


freebase.list = (q, options, callback) ->
  callback = callback or console.log
  return callback({})  unless q
  options = options or {}
  options.max = options.max or options.limit or 500
  return fns.doit_async(q, freebase.list, options, callback)  if _.isArray(q) and q.length > 1
  q = fns.singularize(q)  unless q.match(/\/.{1,12}\/.{3}/)
  freebase.get_id q,
    type: "/type/type"
  , (topic) ->
    return callback([])  if not topic or not topic.id
    query = [
      type: topic.id
      name: null
      id: null
      mid: null
      limit: 100
    ]
    if options.extend
      for i of options.extend
        query[0][i] = options.extend[i]
    freebase.paginate query, options, callback


freebase.place_data = (geo, options, callback) ->
  callback = callback or console.log
  return callback({})  unless geo
  options = options or {}
  return fns.doit_async(q, freebase.place_data, options, callback)  if _.isArray(geo) and geo.length > 1
  location =
    coordinates: [geo.lng, geo.lat]
    type: "Point"

  out = [
    mid: null
    name: null
    type: []
  ]
  url = geosearch + "?location=" + encodeURIComponent(JSON.stringify(location)) + "&order_by=distance&limit=1&type=/location/citytown&within=15&format=json&mql_output=" + encodeURIComponent(JSON.stringify(out))
  fns.http url, (r) ->
    all =
      city: null
      country: null
      province: null
      timezone: null

    all.city = r.result.features[0].properties
    query = [
      name: null
      id: r.result.features[0].properties.mid
      "/location/location/containedby": [
        id: null
        name: null
        type: []
        optional: true
        "/location/location/time_zones": [
          "/time/time_zone/offset_from_uct": null
          id: null
          name: null
          optional: true
        ]
        "/location/location/containedby": [
          id: null
          name: null
          type: []
          optional: true
          "/location/location/time_zones": [
            "/time/time_zone/offset_from_uct": null
            id: null
            name: null
            optional: true
          ]
        ]
      ]
    ]
    freebase.mqlread query, {}, (r) ->
      for i of r.result[0]["/location/location/containedby"]
        v = r.result[0]["/location/location/containedby"][i]
        if v.type.filter((t) ->
          t is "/location/country"
        )[0]
          all.country =
            id: v.id
            name: v.name
        else if v.type.filter((t) ->
          t is "/location/administrative_division"
        )[0]
          all.province =
            id: v.id
            name: v.name
        all.timezone = v["/location/location/time_zones"][0]  if v["/location/location/time_zones"][0] and v["/location/location/time_zones"].length is 1
        return callback(all)  if all.country
        v["/location/location/containedby"].map (o) ->
          if o.type.filter((t) ->
            t is "/location/country"
          )[0]
            all.country =
              id: o.id
              name: o.name
          else if not all.province and o.type.filter((t) ->
            t is "/location/administrative_division"
          )[0]
            all.province =
              id: o.id
              name: o.name
          all.timezone = o["/location/location/time_zones"][0]  if not all.timezone and o["/location/location/time_zones"][0] and o["/location/location/time_zones"].length is 1

      callback all



freebase.incoming = (q, options, callback) ->
  callback = callback or console.log
  return callback({})  unless q
  options = options or {}
  return fns.doit_async(q, freebase.incoming, options, callback)  if _.isArray(q) and q.length > 1
  freebase.get_id q, options, (topic) ->
    return callback([])  if not topic or not topic.id
    query = [
      id: topic.id
      "/type/reflect/any_reverse": [
        link: null
        id: null
        name: null
        type: "/common/topic"
        limit: 170
      ]
    ]
    freebase.paginate query, options, (result) ->
      return callback([])  if not result or not result[0] or not result[0]["/type/reflect/any_reverse"]
      callback result[0]["/type/reflect/any_reverse"]



freebase.outgoing = (q, options, callback) ->
  callback = callback or console.log
  return callback({})  unless q
  options = options or {}
  return fns.doit_async(q, freebase.outgoing, options, callback)  if _.isArray(q) and q.length > 1
  freebase.lookup q, options, (topic) ->
    return callback([])  if not topic or not topic.mid
    freebase.topic topic.mid, options, (result) ->
      out = []
      result.property = kill_boring(result.property)
      Object.keys(result.property).forEach (key) ->
        v = result.property[key]
        if v.valuetype is "object"
          v.values = v.values.map((s) ->
            s.property = key
            s
          )
          out = out.concat(v.values)
        if v.valuetype is "compound"
          v.values.forEach (c) ->
            c.property = kill_boring(c.property)
            Object.keys(c.property).forEach (key2) ->
              if c.property[key2].valuetype is "object"
                c.property[key2].values = c.property[key2].values.map((s) ->
                  s.property = [key, key2]
                  s
                )
                out = out.concat(c.property[key2].values)



      out = out.map((o) ->
        name: o.text
        id: o.id
        property: o.property
      )
      out = out.map((o) ->
        property = o.property
        property = o.property.join("")  if _.isArray(o.property)
        grammar = data.sentence_grammars.filter((v) ->
          v.property is property
        )[0] or {}
        o.sentence = grammar["sentence form"].replace(/\bsubj\b/, topic.name).replace(/\bobj\b/, o.name)  if grammar["sentence form"] and topic.name and o.name
        o
      )
      callback out



freebase.graph = (q, options, callback) ->
  callback = callback or console.log
  return callback({})  unless q
  options = options or {}
  return fns.doit_async(q, freebase.graph, options, callback)  if _.isArray(q) and q.length > 1
  freebase.lookup q, options, (topic) ->
    return callback({})  unless topic
    delete topic.score

    delete topic.lang

    options.filter = "allproperties"
    freebase.topic topic.mid, options, (r) ->
      incoming = {}
      outgoing = {}
      Object.keys(r.property).forEach (k) ->
        if k.match(/^\!/)
          outgoing[k] = r.property[k]
        else
          incoming[k] = r.property[k]

      incoming = parse_topic_api(incoming)
      outgoing = parse_topic_api(outgoing)
      out = incoming.map((v) ->
        subject: topic
        property:
          id: v.property

        object: v
      )
      out = out.concat(outgoing.map((v) ->
        object: topic
        property:
          id: v.property

        subject: v
      ))
      out = out.map((obj) ->
        property = obj.property.id.replace(/^\!/, "")
        grammar = data.sentence_grammars.filter((v) ->
          v.property is property
        )[0] or {}
        obj.sentence = grammar["sentence form"].replace(/\bsubj\b/, obj.subject.name).replace(/\bobj\b/, obj.object.name)  if grammar["sentence form"] and obj.subject.name and obj.object.name
        obj
      )
      callback out



freebase.related = (q, options, callback) ->
  callback = callback or console.log
  return callback([])  unless q
  options = options or {}
  options.max = options.max or 25
  return fns.doit_async(q, freebase.related, options, callback)  if _.isArray(q) and q.length > 1
  all = []
  freebase.outgoing q, options, (result) ->
    all = result.filter((v) ->
      fns.isin v.property, data.related_properties
    )
    all = all.sort((a, b) ->
      Math.round(Math.random()) - 0.5
    )
    all = all.map((v) ->
      v.sentence = v.name + " is related to " + result.name  unless v.sentence
      v
    )
    all = fns.json_unique(all, "id")
    return callback(all)  if all.length >= options.max
    freebase.notable q, options, (result) ->
      if result and result.id
        freebase.list result.id,
          max: options.max
        , (r) ->
          return callback(all)  unless r
          r = r.map((v) ->
            v.sentence = v.name + " is also a " + result.name
            v
          )
          all = all.concat(r)
          all = fns.json_unique(all, "id")
          all = all.sort((a, b) ->
            Math.round(Math.random()) - 0.5
          )
          callback all

      else
        callback all



freebase.is_a = (q, property, options, callback) ->
  callback = callback or console.log
  return callback([])  unless q
  options = options or {}
  options.max = options.max or 25
  return fns.doit_async(q, freebase.is_a, options, callback)  if _.isArray(q) and q.length > 1
  freebase.topic q, options, (r) ->
    types = r.property["/type/object/type"] or {}
    types = types.values or []
    types = types.filter((v) ->
      not v.text.match(/Topic/)
    )
    types = types.map((v) ->
      name: v.text
      id: v.id
      property: "/type/object/type"
    )
    r = parse_topic_api(r.property)
    r = r.filter((v) ->
      fns.isin v.property, data.is_a
    )
    r = r.concat(types)
    callback r


freebase.question = (q, options, callback) ->
  callback = callback or console.log
  return callback([])  if not q or not options.property
  options = options or {}
  options.max = options.max or 25
  property = options.property
  type = property.match(/\/.*?\/.*?\//)
  return fns.doit_async(q, freebase.question, options, callback)  if _.isArray(q) and q.length > 1
  if property.match(/^\/.{1,12}\/.{3}/)
    return freebase.topic(q, {}, (r) ->
      return callback([])  if not r or not r.property[property]
      callback r.property[property].values
    )
  candidate_metaschema = metaschema_lookup(property)
  if candidate_metaschema
    options.filter = "(all " + candidate_metaschema + ":\"" + q + "\")"
    freebase.search "", options, (result) ->
      callback result

  else
    candidate_properties = property_lookup(property)
    return callback([])  if candidate_properties.length is 0
    options.filter = type
    freebase.topic q, options, (result) ->
      all = []
      candidate_properties.forEach (p) ->
        all = all.concat(result.property[p.id].values)  if result.property[p.id]

      all = fns.json_unique(all, "id")
      callback all


freebase.dig = (q, options, callback) ->
  callback = callback or console.log
  return callback([])  if not q or not options.property
  options = options or {}
  options.max = options.max or 25
  return freebase.dig(q[0], options, callback)  if _.isArray(q) and q.length > 1
  all = []
  freebase.question q, options, (r) ->
    return callback(all)  if not r or not _.isArray(r) or r.length is 0
    all = all.concat(r)
    r = r.slice(0, options.max).map((v) ->
      v.id
    )
    fns.doit_async r, freebase.question, options, (big) ->
      return callback(all)  if not big or not _.isArray(big) or big.length is 0
      all = all.concat(_.flatten(big, "shallow"))
      all = fns.json_unique(all, "id")
      fns.doit_async r, freebase.question, options, (big) ->
        return callback(all)  if not big or not _.isArray(big) or big.length is 0
        all = all.concat(_.flatten(big, "shallow"))
        all = fns.json_unique(all, "id")
        callback all




freebase.gallery = (q, options, callback) ->
  callback = callback or console.log
  return callback([])  unless q
  options = options or {}
  return fns.doit_async(q, freebase.gallery, options, callback)  if _.isArray(q) and q.length > 1
  options.extend = "/common/topic/image": [
    id: null
    optional: "required"
  ]
  freebase.list q, options, (result) ->
    result = result.map((obj) ->
      obj.href = image_host + _.last(obj["/common/topic/image"]).id
      obj.thumbnail = image_host + _.last(obj["/common/topic/image"]).id + "?mode=fillcropmid&maxwidth=150&maxheight=150&errorid=/m/0djw4wd"
      obj = freebase.add_widget(obj)
      obj
    )
    callback result


freebase.wordnet = (q, options, callback) ->
  callback = callback or console.log
  return callback([])  unless q
  options = options or {}
  return fns.doit_async(q, freebase.wordnet, options, callback)  if _.isArray(q) and q.length > 1
  query = [
    id: null
    type: "/base/wordnet/synset"
    gloss: null
    syntactic_category: null
    sort: ["syntactic_category", "word.sense_number", "a:word.word_number"]
    word:
      sense_number: null
      derivationally_related_forms: [
        sense:
          name: null
          id: null

        optional: true
      ]
      word:
        word: q

    "a:word": [
      word_number: null
      word:
        word: null
    ]
  ]
  freebase.paginate query, options, (r) ->
    callback r


freebase.transitive = transitive = (q, property, options, callback) ->
  callback = callback or console.log
  return callback([])  if not q or not property
  options = options or {}
  return fns.doit_async(q, property, freebase.transitive, options, callback)  if _.isArray(q) and q.length > 1
  freebase.get_id q, options, (topic) ->
    return callback({})  if not topic or not topic.id
    candidate_metaschema = metaschema_lookup(property)
    if candidate_metaschema
      options.filter = "(all " + candidate_metaschema + ":\"" + topic.id + "\")"
      freebase.search "", options, (result) ->
        callback result

    else
      callback []


freebase.geolocation = (q, options, callback) ->
  callback = callback or console.log
  return callback({})  unless q
  options = options or {}
  return fns.doit_async(q, freebase.geolocation, options, callback)  if _.isArray(q) and q.length > 1
  options.type = options.type or "/location/location"
  freebase.get_id q, options, (topic) ->
    return callback({})  if not topic or not topic.id
    query = [
      id: topic.id
      name: null
      "/location/location/geolocation": [
        latitude: null
        longitude: null
        type: "/location/geocode"
        optional: true
      ]
    ]
    freebase.mqlread query, options, (result) ->
      if result.result and result.result[0] and result.result[0]["/location/location/geolocation"][0]
        geo = result.result[0]["/location/location/geolocation"][0]
        delete geo.type

        delete geo.optional

        return callback(geo)
      callback {}



freebase.nearby = (q, options, callback) ->
  callback = callback or console.log
  return callback([])  unless q
  options = options or {}
  return fns.doit_async(q, freebase.nearby, options, callback)  if _.isArray(q) and q.length > 1
  freebase.geolocation q, {}, (geo) ->
    return callback([])  if not geo or not geo.latitude or not geo.longitude
    location = "{\"coordinates\":[" + geo.longitude + "," + geo.latitude + "],\"type\":\"Point\"}"
    options.within = options.within or 5
    options.type = options.type or "/location/location"
    url = geosearch + "?location=" + encodeURIComponent(location) + "&order_by=distance&type=" + options.type + "&within=" + options.within + "&limit=200&format=json"
    fns.http url, (r) ->
      callback r.result.features



freebase.inside = (q, options, callback) ->
  callback = callback or console.log
  return callback([])  unless q
  options = options or {}
  return fns.doit_async(q, freebase.inside, options, callback)  if _.isArray(q) and q.length > 1
  options.mql_output = options.mql_output or [
    name: null
    id: null
    type: "/location/location"
    "/location/location/geolocation": [
      latitude: null
      longitude: null
      type: "/location/geocode"
      optional: true
    ]
  ]
  freebase.transitive q, "part_of", options, (r) ->
    callback r


freebase.dbpedia_page = (q, options, callback) ->
  callback = callback or console.log
  return callback({})  unless q
  options = options or {}
  return fns.doit_async(q, freebase.dbpedia_page, options, callback)  if _.isArray(q) and q.length > 1
  freebase.get_id q, options, (topic) ->
    return callback("")  if not topic or not topic.id
    query = [
      id: topic.id
      name: null
      key:
        namespace: "/wikipedia/en_title"
        value: null
    ]
    freebase.mqlread query, options, (result) ->
      return callback("")  if not result or not result.result or not result.result[0] or not result.result[0].key.value
      callback "http://dbpedia.org/resource/" + encodeURIComponent(result.result[0].key.value)



freebase.dbpedia_data = (q, options, callback) ->
  callback = callback or console.log
  return callback({})  unless q
  options = options or {}
  return fns.doit_async(q, freebase.dbpedia_data, options, callback)  if _.isArray(q) and q.length > 1
  freebase.get_id q, options, (topic) ->
    return callback("")  if not topic or not topic.id
    query = [
      id: topic.id
      name: null
      key:
        namespace: "/wikipedia/en_title"
        value: null
    ]
    freebase.mqlread query, options, (result) ->
      return callback("")  if not result or not result.result or not result.result[0] or not result.result[0].key.value
      subj = "http://dbpedia.org/resource/" + fns.mql_unencode(result.result[0].key.value)
      url = "http://dbpedia.org/data/" + encodeURIComponent(fns.mql_unencode(result.result[0].key.value)) + ".json"
      fns.http url, (result) ->
        all = Object.keys(result).map((i) ->
          subject:
            dbpedia: subj
            id: dbpedia_to_freebase(subj)

          property:
            dbpedia: Object.keys(result[i])[0]

          object:
            dbpedia: i
            id: dbpedia_to_freebase(i)
        )
        callback all




freebase.wikipedia_page = (q, options, callback) ->
  callback = callback or console.log
  return callback({})  unless q
  options = options or {}
  return fns.doit_async(q, freebase.wikipedia_page, options, callback)  if _.isArray(q) and q.length > 1
  freebase.get_id q, options, (topic) ->
    return callback("")  if not topic or not topic.id
    query = [
      id: topic.id
      name: null
      key:
        namespace: "/wikipedia/en_title"
        value: null
    ]
    freebase.mqlread query, options, (result) ->
      return callback("")  if not result or not result.result or not result.result[0]
      callback fns.mql_unencode(result.result[0].key.value)



freebase.wikipedia_categories = (q, options, callback) ->
  callback = callback or console.log
  return callback([])  unless q
  options = options or {}
  return fns.doit_async(q, freebase.wikipedia_categories, options, callback)  if _.isArray(q) and q.length > 1
  if q.match(RegExp(" ")) or q.substr(0, 1) is q.substr(0, 1).toLowerCase() or q.match(/^\//)
    return freebase.wikipedia_page(q, options, (r) ->
      freebase.wikipedia_categories r, options, callback
    )
  url = wikipedia_host + "?action=query&prop=categories&format=json&clshow=!hidden&cllimit=200&titles=" + encodeURIComponent(q)
  fns.http url, (r) ->
    return callback([])  if not r or not r.query or not r.query.pages or not r.query.pages[Object.keys(r.query.pages)[0]]
    cats = r.query.pages[Object.keys(r.query.pages)[0]].categories or []
    cats = cats.map((v) ->
      v.title
    )
    callback cats


freebase.wikipedia_links = (q, options, callback) ->
  callback = callback or console.log
  return callback({})  unless q
  options = options or {}
  return fns.doit_async(q, freebase.wikipedia_links, options, callback)  if _.isArray(q) and q.length > 1
  if q.match(RegExp(" ")) or q.substr(0, 1) is q.substr(0, 1).toLowerCase() or q.match(/^\//)
    return freebase.wikipedia_page(q, options, (r) ->
      freebase.wikipedia_links r, options, callback
    )
  url = wikipedia_host + "?action=query&prop=links&format=json&plnamespace=0&pllimit=500&titles=" + encodeURIComponent(q)
  fns.http url, (r) ->
    return callback([])  if not r or not r.query or not r.query.pages or not r.query.pages[Object.keys(r.query.pages)[0]]
    links = r.query.pages[Object.keys(r.query.pages)[0]].links or []
    links = links.filter((v) ->
      not v.title.match(/^List of /i)?
    )
    links = links.map((o) ->
      o.id = "/wikipedia/en/" + fns.mql_encode(o.title.replace(RegExp(" ", "g"), "_"))
      o.name = o.title
      delete o.title

      delete o.ns

      o
    )
    callback links


freebase.wikipedia_external_links = (q, options, callback) ->
  callback = callback or console.log
  return callback({})  unless q
  options = options or {}
  return fns.doit_async(q, freebase.wikipedia_external_links, options, callback)  if _.isArray(q) and q.length > 1
  if q.match(RegExp(" ")) or q.substr(0, 1) is q.substr(0, 1).toLowerCase() or q.match(/^\//)
    return freebase.wikipedia_page(q, options, (r) ->
      freebase.wikipedia_external_links r, options, callback
    )
  url = wikipedia_host + "?action=query&prop=extlinks&format=json&plnamespace=0&pllimit=500&titles=" + encodeURIComponent(q)
  fns.http url, (r) ->
    return callback([])  if not r or not r.query or not r.query.pages or not r.query.pages[Object.keys(r.query.pages)[0]]
    links = r.query.pages[Object.keys(r.query.pages)[0]].extlinks or []
    links = links.filter((v) ->
      v["*"].match /^http/
    )
    links = links.map((v) ->
      box = fns.parseurl(v["*"])
      url: v["*"]
      domain: box.host
    )
    callback links


freebase.add_widget = (obj) ->
  id = obj.mid or obj.id
  return obj  if not obj or not id
  html = "<a href=\"#\" class=\"imagewrap\" data-id=\"" + id + "\" style=\"position:relative; width:200px; height:200px;\">" + "<img style=\"border-radius:5px;\" src=\"" + image_host + id + "?maxwidth=200&maxheight=200&errorid=/m/0djw4wd\"/>"
  html += "<div class=\"caption\" style=\"position:absolute; opacity:0.5; background:black; bottom:10px; color:white; left:10px; border-radius: 5px; min-width:100px; padding:5px;\">" + obj.name + "</div>"  if obj.name
  html += "</a>"
  obj.widget = html
  obj


#soften up the api so it will take these methods alternatively..
aliases =
  mqlread: ["query", "mql_read"]
  topic: ["topic_api", "all_data", "data", "everything", "get_data"]
  paginate: ["continue", "all", "each"]
  same_as_links: ["sameas", "sameAs", "sameaslinks", "links", "sameas_links", "external_links", "weblinks"]
  translate: ["translate_to", "multilingual", "i8n", "get_translation"]
  image: ["pic", "photo", "picture", "get_image", "image_url", "image_src"]
  description: ["get_description", "blurb", "get_blurb", "blurb_api", "text", "get_text"]
  notable: ["notable_type", "notabletype", "notable_for", "notable_as", "main_type", "type"]
  place_data: ["city", "country", "province", "place_info", "location_info", "location", "whereis"]
  incoming: ["incoming_links", "incoming_nodes", "inlinks"]
  outgoing: ["outgoing_links", "outgoing_nodes", "outlinks"]
  related: ["related_topics", "similar", "related_to", "get_related"]
  gallery: ["images", "get_images"]
  geolocation: ["geo", "geocoordinates", "geo_location", "lat_lng", "location"]
  nearby: ["near", "close_to"]
  inside: ["inside_of", "within", "contained_by", "contains"]
  mql_encode: ["encode", "escape"]

for i of aliases
  aliases[i].map (v) ->
    freebase[v] = freebase[i]


# console.log(Object.keys(freebase))
module.exports = freebase
